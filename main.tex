\documentclass[a4paper, 12pt]{article} % Artikel-Klasse

%---------------------------------------------------------
% Encoding, language, quotes
%---------------------------------------------------------
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}       % Deutsche Sprache und Silbentrennung
\usepackage{csquotes}             % Für korrekte Anführungszeichen
\usepackage{listings}
\usepackage{xcolor}

%---------------------------------------------------------
% Graphics & PDF
%---------------------------------------------------------
\usepackage{graphicx}
\usepackage{pdfpages}             % Einbinden von PDF-Seiten
\usepackage{caption}              % Verbesserte Bildunterschriften
\usepackage{subcaption}

% Customize settings
% Customize settings for a more compact style
\lstset{
    language=Java,                 % Specify Java language for syntax highlighting
    basicstyle=\ttfamily\small,    % Use smaller monospaced font for code
    keywordstyle=\color{blue},     % Style for keywords
    commentstyle=\color{gray},     % Style for comments
    stringstyle=\color{red},       % Style for strings
    numbers=none,                  % No line numbers
    breaklines=true,               % Break long lines
    frame=none,                    % No frame around the code
    xleftmargin=0pt,               % Remove left margin
    xrightmargin=0pt,              % Remove right margin
    aboveskip=5pt,                 % Reduce space above the code block
    belowskip=5pt                  % Reduce space below the code block
}

%---------------------------------------------------------
% Math, units, spacing, etc.
%---------------------------------------------------------
\usepackage{siunitx}
\usepackage{setspace}
\usepackage{textgreek}

% Add float package for "H" float option
\usepackage{float}

%---------------------------------------------------------
% Other packages
%---------------------------------------------------------
\usepackage{ifthen}
\usepackage{acronym}
\PassOptionsToPackage{hyphens}{url} % URLs in Hyperlinks umbrechen
\usepackage[breaklinks=true]{hyperref} 
\usepackage{array}                % Bessere Tabellenformatierung
\usepackage{enumitem}             % Kontrolle über Listen-Layouts
\usepackage{nomencl}
\usepackage{scrlayer-scrpage}     % Header und Footer

% Adjust header and footer heights
\setlength{\headheight}{14.5pt}
\setlength{\footheight}{34.16666pt}

%---------------------------------------------------------
% Bibliography (biblatex mit Biber)
%---------------------------------------------------------
\usepackage[backend=biber, style=ieee]{biblatex}  
\addbibresource{literatur.bib}  

%---------------------------------------------------------
% Platzhalter
%---------------------------------------------------------
\newcommand{\titel}{Verbesserung eines Bluetooth-basierten Warnsystems für den Straßenverkehr durch Datenlogging und innovative Visualisierungstechniken}
\newcommand{\untertitel}{}
\newcommand{\arbeit}{Studienarbeit T3200}
\newcommand{\studiengang}{Elektrotechnik}
\newcommand{\studienrichtung}{Fahrzeugelektronik}
\newcommand{\autor}{Luka Tadic}
\newcommand{\abgabe}{14.07.2025}
\newcommand{\bearbeitungszeitraum}{07.04.2025 - 14.07.2025}
\newcommand{\matrikelnr}{5726700}
\newcommand{\kurs}{TFE22-1}
\newcommand{\firma}{}
\newcommand{\betreuerfirma}{Prof. Dr. Ing. Tobias Frank}
\newcommand{\gutachterdhbw}{Prof. Dr. Ing. Tobias Frank}
\newcommand{\jahr}{2025}

%---------------------------------------------------------
% Header und Footer mit Linien
%---------------------------------------------------------
\clearpairofpagestyles         % Standard-Stile löschen

% Header with consistent logo placement and line position
\ohead{%
    \raisebox{1cm}[0pt][0pt]{% Raise the logo well above the line
        \includegraphics[width=3cm]{images/DHBW_d_R_FN_46mm_4c}%
    }%
    \\[-1.5cm] % Move the header line down
    \rule{\textwidth}{0.4pt} % Horizontal rule for the header line
}


% Footer with consistent alignment and contents below the line
\setkomafont{pagefoot}{\normalfont} % Ensure consistent font style
\cfoot{%
    \rule{\textwidth}{0.4pt}\\ % Horizontal rule
    \vspace{0.3em} % Small vertical space
    \begin{tabular}{@{}p{0.33\textwidth}p{0.33\textwidth}p{0.33\textwidth}@{}}
        \arbeit & \centering \autor & \raggedleft \thepage
    \end{tabular}
}


\pagestyle{scrheadings}        % Stil aktivieren

%---------------------------------------------------------
% Dokumentbeginn
%---------------------------------------------------------
\begin{document}
\sloppy

%---------------------------------------------------------
% Titelseite
%---------------------------------------------------------
\thispagestyle{empty}  % Kein Header oder Footer auf der Titelseite
\hypersetup{pageanchor=false}

\begin{titlepage}
\enlargethispage{4.0cm}
\sffamily  % Serifenlose Schrift für die Titelseite

\parbox{0.5\linewidth}{
    \begin{flushleft}
        % Optional: Firmenlogo
    \end{flushleft}
}
\parbox{0.5\linewidth}{
    \begin{flushright}
        \includegraphics[width=0.4\linewidth]{images/DHBW_d_R_FN_46mm_4c}\\[5ex]
    \end{flushright}
}

\begin{center}

{\fontsize{20.74pt}{24pt}\selectfont
\textbf{\titel}\\[1.5ex]}

{\fontsize{17pt}{20pt}\selectfont
\textbf{\arbeit}\\[2ex]}

{\fontsize{14pt}{17pt}\selectfont
Studiengang \studiengang\\[2ex]}

{\fontsize{12pt}{14pt}\selectfont
Studienrichtung \studienrichtung\\[1ex]
Duale Hochschule Baden-Württemberg Ravensburg, Campus Friedrichshafen\\[5ex]
von\\[1ex]
\autor\\[15ex]}

\end{center}

\begin{center}
{\fontsize{12pt}{14pt}\selectfont
\begin{tabular}{ll}
Abgabedatum:                    & \quad \abgabe \\  
Bearbeitungszeitraum:           & \quad \bearbeitungszeitraum \\  
Matrikelnummer:                 & \quad \matrikelnr \\  
Kurs:                           & \quad \kurs \\  
Dualer Partner:                 & \quad \firma \\ % entfällt bei Studienarbeit
Betreuerin / Betreuer:          & \quad \betreuerfirma \\  
Gutachterin / Gutachter:        & \quad \gutachterdhbw \\ [2ex]
\end{tabular}
}
\end{center}

\end{titlepage}

\clearpage

\pagestyle{scrheadings}  % Header und Footer nach Titelseite aktivieren
\hypersetup{pageanchor=true}

%---------------------------------------------------------
% Erklärung
%---------------------------------------------------------

\pagenumbering{Roman}

\section*{Erklärung}

Ich versichere hiermit, dass ich meine \arbeit\ mit dem Thema:

\begin{quote}
    \textit{\titel}
\end{quote}

selbstständig verfasst und keine anderen als die angegebenen Quellen und Hilfsmittel benutzt habe.  
Ich versichere zudem, dass die eingereichte elektronische Fassung mit der gedruckten Fassung übereinstimmt.\\[6ex]

Friedrichshafen, den \today \\[1ex]
\rule[-0.2cm]{5cm}{0.5pt} \\  
\autor \\[10ex]

\rmfamily


\clearpage

\section*{Kurzfassung}
  
%---------------------------------------------------------
% Abstract
%---------------------------------------------------------
\section*{Abstract}
\clearpage

\section*{Hilfsmittel}

\clearpage
% List of figures
\addcontentsline*{toc}{section}{}  % Add section to table of contents
\listoffigures

\clearpage

\section*{Abkürzungsverzeichnis}
\begin{acronym}
    \acro{AoA}{Angle-of-Arrival}
    \acro{API}{Application Programming Interface}
    \acro{BLE}{Bluetooth Low Energy}
    \acro{LKW}{Lastkraftwagen}
    \acro{SDK}{Software Development Kit}
    \acro{CSV}{Comma-seperated values}
    \acro{JSON}{JavaScript Object Notation}

\end{acronym}

   

   

   

   







\clearpage


%---------------------------------------------------------
% Inhaltsverzeichnis
%---------------------------------------------------------
\tableofcontents

\clearpage

%---------------------------------------------------------
% Hauptkapitel
%---------------------------------------------------------
\pagenumbering{arabic}
\setcounter{page}{1}

\section{Einleitung}

\subsection{Motivation}
In den letzten Jahren ist die Zahl der tödlichen Verkehrsunfälle bedauerlicherweise gestiegen, was auf eine Vielzahl von Faktoren wie die 
steigende Verkehrsdichte sowie mangelnde Aufmerksamkeit und Sorgfalt im Straßenverkehr zurückzuführen sein kann. 
Um dieser negativen Entwicklung entgegenzuwirken, wurden unterschiedliche Maßnahmen ergriffen. 
Neben strengeren Sicherheitsgesetzen haben sich vor allem technologische Innovationen wie Fahrzeugkameras, 
Sensorik und verschiedene Fahrerassistenzsysteme als wesentliche Instrumente zur Unfallprävention herauskristallisiert.

\begin{figure}[H]
    \includegraphics[width=1\linewidth]{images/abbiegeassistent-scaled-7b2478b8}\\[1ex]
    \centering
    \caption{Beispiel Rechtsabbiegen LKW}
    \label{ABBILDUNG}
\end{figure}


Eine besonders bedeutende Neuerung im Bereich der \acf{LKW}-Sicherheit stellen Abbiegeassistenten dar. 
Diese Systeme helfen, den toten Winkel zu reduzieren und somit Unfälle – insbesondere beim Rechtsabbiegen – zu vermeiden. 
Trotz dieser technischen Fortschritte besteht weiterhin Potenzial für weitere Verbesserungen. Eine umfassende Forschung und Entwicklung 
im Bereich von Fahrerassistenzsystemen könnte zukünftig dazu beitragen, das allgemeine Verkehrsrisiko weiter zu senken und die Verkehrssicherheit
signifikant zu erhöhen. [1]

\clearpage

\subsection{Zielsetzung}
Zielsetzung dieser Studienarbeit ist es, einen 
leistungsfähigen Datenlogger zu entwickeln und die Visualisierung 
zu verbessern, um die Funktionalität des Fahrerassistenzsystems zu erhöhen 
und dadurch dessen Entwicklung zu erleichtern. Durch die Implementierung eines 
leistungsfähigen Datenloggers sollen Messwerte systematisch und zuverlässig 
erfasst werden können, was eine effektivere Zusammenarbeit im Entwicklungsteam 
ermöglicht und die Notwendigkeit einer dauerhaften Hardwareverbindung reduziert. Die Optimierung der Visualisierung 
dient dazu, Messergebnisse klarer und übersichtlicher darzustellen, um künftige Analysen und Tests zu vereinfachen und somit
 die Qualität und Genauigkeit der Positionsbestimmung zu erhöhen. Diese Verbesserungen sollen letztlich zu einer höheren Effizienz
  im Entwicklungsprozess führen und 
somit einen wesentlichen Beitrag zur Erhöhung der Verkehrssicherheit leisten.

\clearpage

\section{Rückblick auf das mobile Warnsystem}
\subsection{Konzept und Zielsetzung}
Die vorherige Studienarbeit verfolgte das Ziel, ein mobiles Warnsystem zur Minimierung von 
Abbiegeunfällen zwischen \ac{LKW} und ungeschützten Verkehrsteilnehmenden wie Fußgängerinnen und Radfahrerinnen zu entwickeln.
Zentrales Element dieses Systems war eine mobile Applikation, die als aktiver Bluetooth-Sender fungieren sollte. In Kombination 
mit einem am \ac{LKW} montierten Empfängerboard (basierend auf dem u-blox XPLR-AOA-1 Kit) sollte mithilfe der \acf{AoA}-Technologie 
die Position des Smartphones lokalisiert und bei drohender Gefahr eine Warnung ausgegeben werden. Das System versprach einen 
kostengünstigen und einfach zugänglichen Ansatz zur Verbesserung der Verkehrssicherheit im städtischen Raum.

\subsection{Bluetooth AoA und technische Grundlagen}
Die \ac{AoA}-Technologie ist Teil des Bluetooth 5.1 Standards und ermöglicht die Positionsbestimmung
 eines Senders durch Messung des Einfallswinkels der Funksignale an mehreren Antennen eines Empfängers. 
 Voraussetzung hierfür ist jedoch ein exakter Zugang zu den Bluetooth-Sendeparametern sowie eine Antennenkonfiguration 
 mit bekannten geometrischen Abständen. Das u-blox XPLR-AOA-1 Explorer Kit stellt hierzu eine geeignete Hardwarelösung dar, 
 da es mit einem \ac{AoA}-fähigen Empfängerboard und einem sogenannten Tag (Sender) ausgestattet ist. Ziel der Arbeit war es, das Smartphone 
 funktional durch diesen Tag zu ersetzen. [1][2][3]

 \begin{figure}[H]
    \includegraphics[width=1\linewidth]{images/XPLR-AOA-with-C209-and-C211-02_0}\\[1ex]
    \centering
    \caption{XPLR-AOA Explorer Kit}
    \label{ABBILDUNG}
\end{figure}

 \subsection{Herausforderungen und Gründe für die Projektpause}
 Im praktischen Verlauf der Umsetzung traten mehrere schwerwiegende technische Limitierungen auf, die die Fortführung des Projekts verhinderten:

 \begin{itemize}
    \item Aktuelle Smartphone-Firmware (insbesondere auf Android-Basis) verhindert in der Regel den vollständigen Zugriff auf die Bluetooth-Sendeparameter. Ein gezieltes Emittieren von \acf{BLE}-Signalen, wie es zur \ac{AoA}-Ortung erforderlich ist, ist mit Standard-\acf{SDK} nicht möglich.
    \item Nur wenige aktuelle Mobilgeräte unterstützen Bluetooth 5.1 vollständig, was die Reichweite und Genauigkeit der Ortung stark einschränkt.
    \item Die Emulation des u-blox Tags durch das Smartphone scheiterte daher an mangelnden Systemrechten, fehlender Low-Level-\acf{API}-Zugriffe und nicht ausreichender Hardwareunterstützung.
 \end{itemize}
Diese Faktoren führten dazu, dass das Projekt in der geplanten Form nicht abgeschlossen werden konnte. 
Die zugrundeliegende Idee bleibt jedoch vielversprechend und kann in Zukunft wieder aufgegriffen werden, sobald sich 
die technischen Rahmenbedingungen verbessert haben.[4][5][6][7]

\clearpage

\section{Grundlagen Datenlogger}
\subsection{Zweck und Funktionalität eines Datenloggers}
Ein Datenlogger ist ein autonom arbeitendes Gerät oder Softwaremodul, das physikalische oder digitale Messwerte über einen definierten 
Zeitraum hinweg aufzeichnet. Ziel ist es, Veränderungen systematisch und zuverlässig zu erfassen, um sie später analysieren, auswerten 
oder dokumentieren zu können. Typische erfasste Daten umfassen beispielsweise Temperatur, Spannung, Zeitstempel, Lage- oder Positionsdaten.

\begin{figure}[H]
    \includegraphics[width=1\linewidth]{images/Datalogger}\\[1ex]
    \centering
    \caption{Datenlogger Cube (Avisaro 2.0) zur Speicherung von Sensor- und Prozessdaten}
    \label{ABBILDUNG}
\end{figure}

Im Gegensatz zu interaktiven Messsystemen arbeitet ein Datenlogger in der Regel unabhängig und ohne dauerhafte Verbindung 
zu einem Steuergerät. Dies macht ihn besonders geeignet für mobile oder schwer zugängliche Anwendungen. Durch kontinuierliche 
Aufzeichnung lassen sich Messwerte nachvollziehbar dokumentieren, was vor allem in der Entwicklung, Fehlersuche und Validierung technischer 
Systeme von Bedeutung ist.

Wichtige Eigenschaften eines Datenloggers sind unter anderem eine ausreichende Speicherkapazität, 
Energieeffizienz und die Kompatibilität zu verschiedenen Datenformaten wie \acf{CSV} oder \acf{JSON}. Moderne Logger 
bieten darüber hinaus Schnittstellen für drahtlose Datenübertragung oder automatisierte Synchronisation mit Analysetools.

\subsection{Anwendungsbereiche im Kontext der Studienarbeit}
Im Rahmen dieser Studienarbeit wird der Datenlogger gezielt eingesetzt, um die Entwicklungsarbeit am Bluetooth-\ac{AoA}-basierten
 Lokalisierungssystem effizienter und flexibler zu gestalten. Ziel ist es, die Abhängigkeit von einer aktiven Verbindung zur 
 Hardware während der Test- und Anpassungsphasen zu minimieren. Personen, die an der Parametrierung oder Feinjustierung des Systems
  arbeiten, sollen in die Lage versetzt werden, auch ohne direkte Verbindung zur u-blox-Hardware auf reale Messdaten zuzugreifen.

Der Datenlogger dient dabei nicht nur der reinen Aufzeichnung, sondern ermöglicht die Speicherung von tatsächlich erfassten, 
originalgetreuen Messwerten. Diese Werte können anschließend in separate Programme oder Auswertungswerkzeuge importiert werden,
 um dort Berechnungen, Analysen und grafische Darstellungen durchzuführen. Änderungen an Parametern oder Auswertealgorithmen können 
 somit auf Basis gespeicherter Daten vorgenommen und getestet werden, ohne dass dafür eine erneute Datenerfassung mit der realen Sensorik notwendig ist.

Darüber hinaus erlaubt der Datenlogger eine „Offline-Simulation“ oder ein Daten-Replay mit echten Werten. Diese Vorgehensweise bietet den 
Vorteil, dass Optimierungen zunächst im Testsystem geprüft werden können. Erst wenn ein Ergebnis zufriedenstellend ist, wird es auf das reale 
System übertragen. Damit leistet der Datenlogger einen wesentlichen Beitrag zur Entkopplung von Entwicklung und Hardwareverfügbarkeit, 
was vor allem in Teamkonstellationen und bei paralleler Arbeit an mehreren Teilaspekten des Systems von großem Nutzen ist.

\subsection{Vorhandene Herausforderungen und Lösungsansätze}
Bei der Entwicklung eines zuverlässigen Datenloggers im Kontext des Bluetooth \ac{AoA}-Systems treten verschiedene Herausforderungen auf. 
Eine der zentralen Schwierigkeiten liegt in der exakten zeitlichen Zuordnung der erfassten Daten. Für eine sinnvolle Auswertung müssen 
Zeitstempel, Empfangswinkel und weitere Messgrößen synchronisiert und konsistent gespeichert werden.

Ein weiteres Problem stellt die effiziente und verlustfreie Speicherung großer Datenmengen dar. 
Hierbei müssen sowohl die Speicherkapazität als auch die Lesbarkeit und Weiterverwendbarkeit berücksichtigt werden. Gerade 
im Hinblick auf die spätere Analyse mit gängigen Tools wie Python oder MATLAB ist ein gut strukturiertes Datenformat – etwa \ac{CSV} oder \ac{JSON} – von 
hoher Bedeutung.

Auch die Integration in bestehende Entwicklungsprozesse erfordert eine durchdachte Schnittstellengestaltung.
 Der Datenlogger muss flexibel und modular aufgebaut sein, damit er problemlos in verschiedene Testumgebungen 
 eingebunden werden kann. Gleichzeitig soll der Energieverbrauch möglichst gering gehalten werden, um auch den mobilen Einsatz über längere
  Zeiträume hinweg zu ermöglichen.

Lösungsansätze bestehen in der Verwendung eines einfachen, standardisierten Speicherformats, einem modularen 
Softwaredesign mit klar dokumentierten Schnittstellen sowie in der Implementierung grundlegender Fehlererkennungs- und Synchronisationsmechanismen. 
Diese Maßnahmen sollen sicherstellen, dass der Datenlogger zuverlässig, energieeffizient und nutzerfreundlich eingesetzt werden kann.

\clearpage

\section{Entwicklung des Datenloggers}
\subsection{Anforderungen an die Software}
Die bestehende Softwarebasis setzt bereits auf eine performante C++-Schicht für die zeitkritische Kommunikation mit 
der u-blox-Hardware und auf ergänzende Python-Skripte für Tests und Auswertungen. Dieses zweistufige Konzept bleibt erhalten: 
Der neue Datenlogger wird vollständig in Python implementiert und greift über schlanke Schnittstellen auf die vorhandenen C++-Funktionen zu. 
So können Erweiterungen schnell umgesetzt werden, ohne den stabilen Kerncode anzutasten.

Als Speicherformat dient \ac{JSON}. Es ermöglicht, Messwerte – etwa Zeitstempel, \ac{AoA}-Winkel, Signalstärke und relevante Metadaten – in einer 
klar strukturierten, menschenlesbaren Datei abzulegen. Die Dateien lassen sich bei Bedarf komprimieren und ohne Konvertierung in gängige 
Analyse- oder Visualisierungsprogramme importieren.

Diese Kombination aus C++ (für hardwarenahen Durchsatz) und Python (für flexible Daten­verarbeitung) erfüllt die Anforderungen 
an Zuverlässigkeit, Erweiterbarkeit und unkomplizierte Offline-Analyse. Sie stellt zudem sicher, dass Teammitglieder auch ohne direkten 
Hardwarezugriff reale Datensätze einspielen, parametrieren und visualisieren können.

[8][9]
\subsection{Auswahl geeigneter Technologien und Tools}
Für die Erweiterung des bestehenden Prototyps wurde bewusst an der zweigeteilten Sprachebene festgehalten: 
zeitkritische Kommunikation und Treiberfunktionen laufen weiterhin in C++, während der neue Datenlogger in Python 
implementiert wird. So können die vorhandenen C++-Routinen unverändert genutzt werden, während Python durch seine hohe 
Entwicklungsgeschwindigkeit schnelle Anpassungen und Auswertungen ermöglicht.

Als Speicherformat wurde \ac{JSON} gewählt. Es erlaubt, Messwerte – etwa Zeitstempel, Winkel und 
Signalstärke – zusammen mit Metadaten in einer klaren, hierarchischen Struktur abzulegen. Die Dateien bleiben damit menschenlesbar 
und lassen sich ohne Umwege in gängige Analyse- und Visualisierungswerkzeuge importieren. Bei Bedarf kann eine Kompression eingesetzt werden, 
um Speicherplatz zu sparen.

Mit dieser Kombination werden die in Abschnitt 4.1 genannten Anforderungen erfüllt: Die Lösung ist leicht erweiterbar, 
plattform­unabhängig und stellt die Daten in einem Format bereit, das direkt für Offline-Analysen genutzt werden kann.

\subsection{Implementierung und Integration in bestehende Systeme}

Die Implementierung des Datenloggers erfolgte im Rahmen eines bestehenden Lokalisierungssystems, das auf der Bluetooth-\ac{AoA}-Technologie 
basiert. Ziel war es, die Erfassung, Speicherung und spätere Analyse von Messwerten so zu gestalten, dass diese unabhängig
von einer Live-Hardwareverbindung möglich ist und flexibel in den Entwicklungsprozess integriert werden kann.

\paragraph{Messung – Entstehung der Rohdaten}

Im Zentrum der Messung stehen zwei Hauptkomponenten: das sogenannte \textit{Tag}, das als zu verfolgendes Objekt fungiert 
und kontinuierlich Signale sendet, sowie mindestens zwei \textit{Anker} (Anchors), die als fest installierte Empfangseinheiten dienen. 
Die Anker, ausgestattet mit mehreren Antennen, empfangen das Signal des Tags und bestimmen den Einfallswinkel (\acf{AoA}), unter dem 
das Signal ankommt. Zusätzlich werden häufig weitere Sensordaten erfasst, beispielsweise Geschwindigkeit oder Risikoabschätzungen.

\paragraph{Datenerfassung und -aufbereitung}

Die Kommunikation zwischen Ankern und Rechner erfolgt typischerweise über eine serielle Schnittstelle oder \ac{BLE}. 
Ein Python-Skript (z.\,B. \texttt{getAnchorData.py}) liest die Rohdaten kontinuierlich aus. Für jede einzelne Messung werden strukturierte Informationen
erfasst, darunter:

\begin{itemize}
    \item \texttt{anchors}: Positionen der Anker, z.\,B. \texttt{[[3, 0], [0, 0]]}
    \item \texttt{angles}: Die gemessenen Winkel, z.\,B. \texttt{[-31, 24]}
    \item \texttt{sensor\_values}: Eine Liste weiterer Sensordaten:
\begin{lstlisting}[language=]
[
  {"theta": 90, "val": -31, "pos": [3, 0], "speed_along_line": 0, "risk_level": 1},
  {"theta": 90, "val": 24, "pos": [0, 0], "speed_along_line": 0, "risk_level": 1}
]
\end{lstlisting}
\end{itemize}

Die Daten werden zeilenweise im JSON Lines-Format (\texttt{.jsonl}) gespeichert. Jede Zeile enthält einen Zeitstempel und die zugehörigen Sensordaten. 
Ein Beispiel für eine gespeicherte Messung ist:

\begin{verbatim}
{"timestamp": "2025-06-03T06:32:50.140342", 
 "raw_sensor_data": {
   "anchors": [[3, 0], [0, 0]], 
   "angles": [-31, 24], 
   "sensor_values": [...]
 }}
\end{verbatim}

\paragraph{Berechnung der Tag-Position – Triangulation}

Aus den gemessenen Winkeln und bekannten Positionen der Anker wird die Position des Tags durch Triangulation berechnet. Jeder Anker 
definiert eine Gerade, auf der sich der Tag befinden könnte. Die Schnittpunktberechnung dieser Geraden liefert eine Positionsschätzung. Die Richtung 
jeder Linie ergibt sich aus dem gemessenen Winkel mittels:

\[
dx = \sin(\theta), \quad dy = \cos(\theta)
\]

Der Schnittpunkt wird mithilfe der folgenden Gleichung bestimmt:

\[
t_1 = \frac{(x_2 - x_1) \cdot dy_2 - (y_2 - y_1) \cdot dx_2}
           {dx_1 \cdot dy_2 - dy_1 \cdot dx_2}
\]

und

\[
x = x_1 + t_1 \cdot dx_1, \quad y = y_1 + t_1 \cdot dy_1
\]

Diese Berechnung kann sowohl live während der Datenerfassung als auch im Nachgang im sogenannten Replay-Modus erfolgen.

\begin{figure}[H]
    \includegraphics[width=1\linewidth]{images/1906_abbildung1 (1)}\\[1ex]
    \centering
    \caption{Beispiel Triangulation}
    \label{ABBILDUNG}
\end{figure}

\paragraph{Speicherung und Weiterverarbeitung}

Sämtliche berechneten Werte – Winkel, Position, Sensordaten – werden chronologisch gespeichert. Das Python-Skript \texttt{replayLogger.py} 
ermöglicht das Einlesen dieser Datei und berechnet bei Bedarf die Position erneut. Dies erlaubt eine erneute Analyse oder die Anwendung überarbeiteter 
Algorithmen.

\paragraph{Nachträgliche Optimierung der Rechenlogik}

Während der frühen Entwicklungsphase bestand ein grundlegendes Problem darin, dass beim Replay die gespeicherten Daten lediglich wiedergegeben wurden, wie sie während der ursprünglichen Messung aufgezeichnet worden waren. Das bedeutete, dass keine Neuberechnung der Tag-Position erfolgte – Anpassungen an Parametern oder Algorithmen blieben somit wirkungslos. 

Im weiteren Verlauf wurde dieser Fehler behoben. Das Replay-Modul (\texttt{replayLogger.py}) wurde so erweitert, dass beim Einlesen der Logdaten die gespeicherten Rohwerte wie Winkel und Ankerpositionen erneut verarbeitet werden. Auf diese Weise erfolgt bei jedem Replay eine aktuelle Berechnung der Position mittels Triangulation. Dadurch können Änderungen in der Positionsberechnung zunächst rein softwareseitig überprüft und validiert werden – ganz ohne Hardwareeinsatz. Nach erfolgreicher Evaluierung lassen sich die neuen Parameter und Berechnungsverfahren schließlich in das Echtzeit-Tracking-System übernehmen.

\paragraph{Visualisierung der Messdaten}

Der Datenlogger stellt über eine TCP-Verbindung eine Schnittstelle zur grafischen Visualisierung her (z.\,B. durch das Skript \texttt{ui.py}). 
Jede Messung wird als \ac{JSON}-Objekt an die Benutzeroberfläche übertragen und enthält neben der berechneten Position auch zugehörige Sensordaten. 
Die Benutzeroberfläche stellt folgende Informationen dar:

\begin{itemize}
    \item Die aktuelle Position des Tags
    \item Visualisierte Sensorwerte (z.\,B. durch Farben, Pfeile oder Symbole)
    \item Zusatzinformationen wie Bewegung oder Risikobewertung
\end{itemize}

\paragraph{Zusammenfassung des Datenflusses}

Der vollständige Ablauf lässt sich wie folgt beschreiben:

\begin{enumerate}
    \item \textbf{Messung:} Anker empfangen Signale und bestimmen Winkel sowie Sensordaten.
    \item \textbf{Datenerfassung:} Python-Skripte lesen die Daten aus und speichern sie als JSONL.
    \item \textbf{Speicherung:} Die Daten werden zeilenweise mit Zeitstempel archiviert.
    \item \textbf{Replay:} Ein weiteres Skript liest die Daten, berechnet ggf. die Position und sendet sie weiter.
    \item \textbf{Visualisierung:} Eine Benutzeroberfläche stellt Position und Sensordaten visuell dar.
\end{enumerate}

\paragraph{Beispiel einer vollständigen Messung}

\begin{itemize}
    \item Anker 1: Winkel = \(-31^\circ\), Position = [3, 0]
    \item Anker 2: Winkel = \(24^\circ\), Position = [0, 0]
\end{itemize}

\textbf{Speicherung:}
\begin{verbatim}
{"timestamp": "...", 
 "raw_sensor_data": {
   "anchors": [[3, 0], [0, 0]], 
   "angles": [-31, 24], 
   "sensor_values": [...]
 }}
\end{verbatim}

\textbf{Replay:}  
Der Datenlogger berechnet erneut die Position und sendet z.\,B.:

\begin{verbatim}
{"point": {"position": [x, y], "Uncertainty": 0}, 
 "sensor_values": [...]}
\end{verbatim}

\textbf{Visualisierung:}  
Die Benutzeroberfläche zeigt Position, Bewegung und Risikobewertung an.

\paragraph{Fazit}

Durch die Trennung von Messung, Speicherung, Wiederverwendung und Visualisierung wurde ein System geschaffen, 
das sowohl im Live-Betrieb als auch für Offline-Analysen geeignet ist. Die Nutzung des \ac{JSONL}-Formats gewährleistet einfache 
Nachverarbeitung und hohe Transparenz im Entwicklungsprozess.

\subsection{Ergebnisse und Evaluation}

Die Implementierung des Datenloggers konnte erfolgreich in die bestehende Systemumgebung integriert werden. Die Erweiterung 
erfolgte durch ein einzelnes, in Python geschriebenes Modul, das mit nur wenigen Anpassungen in den vorhandenen Code eingebunden wurde. 
Diese modulare Herangehensweise ermöglichte eine einfache Integration, ohne die Stabilität der bestehenden C++- und Python-Strukturen zu beeinträchtigen.

Der Datenlogger ist in der Lage, strukturierte Messdaten zuverlässig zu erfassen, im JSONL-Format zu speichern und diese in der 
\texttt{replayLogger.py} zur erneuten Verarbeitung und Visualisierung bereitzustellen. Durch die gezielte Nachberechnung der gespeicherten 
Parameter kann die Parametrisierung und Optimierung der Tag-Ortung nun auch ohne aktiven Hardwarezugang erfolgen. Dies stellt einen wesentlichen
 Fortschritt gegenüber früheren Ansätzen dar, bei denen für jede Änderung eine Live-Verbindung zur u-blox-Hardware erforderlich war.

Zur weiteren Erleichterung der Nutzung wurde eine Batch-Datei (BAT-Datei) erstellt, die den Datenlogger automatisch 
startet und eine benutzerfreundliche Auswahl der abzuspielenden Daten ermöglicht. Dadurch können mehrere aufgezeichnete Datensätze
 parallel gespeichert, umbenannt und bei Bedarf erneut abgespielt werden. Dies erleichtert sowohl die Organisation als auch die Wiederverwendbarkeit
  der Messdaten erheblich.

Die Kommunikation zwischen Logger und Visualisierung über TCP funktioniert stabil, sodass eine Echtzeit- oder zeitnahe Darstellung 
der Messdaten in der grafischen Oberfläche möglich ist. Die Darstellung der Ergebnisse im UI ist erfolgreich umgesetzt worden; die gespeicherten
 Positions- und Sensordaten lassen sich korrekt laden und werden visuell ansprechend aufbereitet.

Ein weiterer Vorteil liegt in der verbesserten Teamfähigkeit des Systems. Da echte Messwerte gespeichert und wiederverwendet werden können, 
ist eine parallele Bearbeitung durch mehrere Teammitglieder möglich – unabhängig von der Verfügbarkeit der physischen Hardware.

Aktuell wurden nur kurze bis mittellange Messreihen (mehrere Minuten) getestet, die zuverlässig aufgezeichnet und verarbeitet werden konnten. 
Für den produktiven Einsatz müssen jedoch noch weiterführende Tests mit längeren Aufzeichnungen durchgeführt werden, um Speicherstabilität und 
Verarbeitungsgeschwindigkeit auch bei größeren Datenmengen zu validieren.

Insgesamt bildet der Datenlogger eine stabile Grundlage für künftige Entwicklungs- und Testarbeiten und ermöglicht sowohl effizientere als auch 
hardwareunabhängige Validierungsprozesse.


\clearpage

\section{Grundlagen der Visualisierung}
\subsection{Anforderungen an eine effektive Visualisierung}

Die visuelle Darstellung von Mess- und Sensordaten spielt eine zentrale Rolle bei der Entwicklung technischer Systeme. 
Im Kontext dieser Studienarbeit soll die Visualisierung nicht nur als Ausgabeinstrument dienen, sondern als aktives Analysewerkzeug die 
Entwicklung des Fahrerassistenzsystems unterstützen. Daraus ergeben sich spezifische Anforderungen an Struktur, Funktionalität und Performance der 
Visualisierung.

Ein wesentliches Kriterium ist die \textbf{Klarheit und Verständlichkeit} der Darstellung. Die Position des zu 
verfolgenden Objekts (Tag), die Winkelmessungen sowie weitere Sensordaten wie Geschwindigkeit oder Risikoindikatoren müssen 
für die Benutzer klar erkennbar und intuitiv interpretierbar sein. Die gewählte Darstellungsform darf keine zusätzliche Komplexität 
einführen, sondern soll das Verständnis der Systemdynamik fördern.

Zudem ist \textbf{Reaktionsfähigkeit} von hoher Bedeutung. Insbesondere bei der Wiedergabe von Logdaten im Replay-Modus ist sicherzustellen, 
dass Positionsdaten und Zustandsänderungen nahezu in Echtzeit visualisiert werden, ohne spürbare Verzögerung oder Datenverluste. Dies ist entscheidend
 für die genaue Nachverfolgung zeitkritischer Situationen und zur Validierung der Algorithmen.

Eine \textbf{strukturierte und modulare Darstellung} ermöglicht es, verschiedene Datenebenen simultan darzustellen. 
Dazu gehören beispielsweise die grafische Repräsentation von Ankerpositionen, Trajektorien, Messwinkeln sowie Risikoabschätzungen in Form von 
Farbcodierungen, Symbolen oder Vektorpfeilen. Die visuelle Trennung dieser Elemente soll die Lesbarkeit erhöhen und gleichzeitig Korrelationen zwischen 
den Daten sichtbar machen.

Weiterhin ist \textbf{Flexibilität} in der Konfiguration erforderlich. Die Visualisierung soll es erlauben, verschiedene Parameter interaktiv zu 
ändern, Messbereiche einzugrenzen oder unterschiedliche Datensätze zu vergleichen. Funktionen wie Zoom, Zeitfilterung oder Layer-Kontrolle erleichtern 
die gezielte Analyse.

Die Software muss zudem eine \textbf{hohe Stabilität und Performance} aufweisen. Auch bei großen Datenmengen oder längeren Wiedergaben dürfen keine 
Speicherprobleme oder Verzögerungen auftreten. Gleichzeitig soll der Ressourcenverbrauch moderat bleiben, um eine Nutzung auf Standardhardware zu 
gewährleisten.

Darüber hinaus ist die \textbf{Schnittstellenkompatibilität} entscheidend. Die Visualisierung kommuniziert über eine TCP-Verbindung mit dem Datenlogger 
und verarbeitet strukturierte JSON-Daten. Sie muss in der Lage sein, kontinuierlich neue Informationen entgegenzunehmen, korrekt zu interpretieren und 
grafisch darzustellen.

Schließlich sollte die Visualisierung eine \textbf{benutzerfreundliche Interaktion} bieten. Die Bedienoberfläche muss auch für neue Projektmitglieder
 oder externe Tester leicht verständlich sein. Ergänzende Funktionen wie Legenden, Tooltips oder Echtzeit-Feedback erhöhen die Zugänglichkeit und 
 erleichtern die Nutzung im Entwicklungsteam.

\subsection{Darstellungsmöglichkeiten und -technologien}

Die grafische Darstellung von Messergebnissen ist ein zentrales Element zur Analyse, Entwicklung und Validierung des Fahrerassistenzsystems.
 Ziel der Visualisierung ist es, komplexe Daten wie Winkelmessungen, berechnete Positionen und Sensordaten so aufzubereiten, dass sie schnell
  erfasst und zielgerichtet interpretiert werden können.

\paragraph{Darstellungsformen}

Für die Anforderungen dieses Projekts wurde eine zweidimensionale Darstellung gewählt. In einem kartesischen Koordinatensystem werden sowohl 
die festen Positionen der Anker als auch die berechnete Position des Tags eingezeichnet. Die Bewegungsrichtung kann über eine Spurhistorie 
(Trajektorie) oder durch Richtungspfeile visualisiert werden. Zur Darstellung zusätzlicher Informationen, wie beispielsweise der Risikobewertung, 
kommt eine Farbcodierung zum Einsatz: Je nach Risiko- oder Geschwindigkeitslevel kann der Datenpunkt beispielsweise in Grün, Gelb oder Rot eingefärbt 
werden.

Auch die Darstellung der Sensordaten erfolgt visuell, etwa durch Richtungslinien oder Symbole, die Informationen wie 
Bewegungsrichtung, Geschwindigkeit oder potenzielle Kollisionsgefahr übermitteln. Ein Beispiel wäre die Anzeige der „Speed along line“-Werte als
 Pfeillänge oder die Kodierung der Risikostufe über ein Symbol oder eine Farbfläche.

Zur besseren Nachvollziehbarkeit der Messabläufe werden zusätzlich Zeitreihen oder Replays implementiert, in denen 
frühere Positionen nacheinander dargestellt werden. Diese dynamische Komponente erleichtert die Bewertung der Bewegungsmuster und 
Reaktionen des Systems über den Zeitverlauf hinweg.

\paragraph{Technologische Umsetzung}

Für die technische Realisierung wurde Python als Basissprache verwendet, da es bereits im bestehenden Projektumfeld (z.\,B. Datenlogger, TCP-Client)
 genutzt wird und eine Vielzahl an Visualisierungsbibliotheken bietet. Die grafische Benutzeroberfläche basiert auf einem einfachen Zeichenfenster, das 
 Datenpunkte und Zusatzinformationen visuell aufbereitet. 

Zur Anzeige der Daten kommen vor allem folgende Bibliotheken und Technologien zum Einsatz:

\begin{itemize}
    \item \textbf{Matplotlib:} Für einfache 2D-Visualisierung der Anker, Tags und Bewegungslinien.
    \item \textbf{Pygame (alternativ):} Bei Bedarf für performantere, interaktive Darstellungen mit benutzerdefinierter Steuerung.
    \item \textbf{TCP-Kommunikation:} Die Visualisierung empfängt die Daten über eine TCP-Verbindung, die vom Datenlogger bereitgestellt wird (z.\,B. Skript \texttt{ui.py}).
    \item \textbf{JSON-Verarbeitung:} Die Logdateien und Echtzeitdaten liegen im JSON- bzw. JSONL-Format vor und werden zeilenweise eingelesen.
\end{itemize}

Der Aufbau der Visualisierung ist modular gehalten, sodass zukünftige Änderungen – etwa am Format der Sensordaten oder an der
 Positionsberechnung – ohne tiefgreifende Eingriffe umgesetzt werden können.

\paragraph{Schnittstellen und Erweiterbarkeit}

Die Benutzeroberfläche ist so gestaltet, dass verschiedene Datenquellen unterstützt werden: Neben Live-Daten aus dem Logger ist auch ein 
Replay-Modus möglich, in dem ältere Messungen abgespielt werden. Dies wird durch einen einfachen Startbefehl (z.\,B. über eine Batch-Datei oder
 Kommandozeilenparameter) gesteuert.

Die Datenstruktur aus der JSONL-Datei ermöglicht eine verlustfreie Weiterverarbeitung der gespeicherten Informationen. Durch die Trennung von 
Backend (Logger/Replay) und Frontend (Visualisierung) ist das System erweiterbar. Eine spätere Portierung auf moderne GUI-Frameworks 
(z.\,B. \texttt{Tkinter}, \texttt{PyQt}, oder webbasierte Tools wie \texttt{Plotly Dash}) ist ebenso denkbar wie eine Erweiterung auf 3D-Darstellungen 
mithilfe von OpenGL oder Unity.

\paragraph{Optionale Abbildungsempfehlung}

Eine illustrative Abbildung könnte den schematischen Ablauf der Datenvisualisierung zeigen – von der Messung über die Speicherung bis zur Anzeige. 
Beispielhaft könnte sie folgende Elemente enthalten:

\begin{itemize}
    \item Position der Anker (als fixe Punkte)
    \item Messwinkel (als Linien vom Anker ausgehend)
    \item Position des Tags (als Punkt mit Zeitstempel)
    \item Risikobewertung als Farbring oder Symbol
    \item Spurverlauf der Tag-Position (z.\,B. gestrichelte Linie)
\end{itemize}

Eine solche schematische Darstellung erleichtert das Verständnis des Visualisierungskonzepts auch für fachfremde Leserinnen und Leser.

\paragraph{Fazit}

Die gewählten Technologien und Darstellungsformen ermöglichen eine performante, verständliche und flexible Visualisierung der Messergebnisse. Sie 
bilden damit eine wichtige Grundlage für die weiterführende Analyse, Parametrisierung und Validierung des Fahrerassistenzsystems.

\clearpage

\section{Entwicklung der neuen Visualisierung}
\subsection{Analyse der bestehenden Visualisierung}

Die bisherige grafische Benutzeroberfläche (UI) wurde in Python entwickelt und diente der Echtzeitdarstellung der aus dem Bluetooth-AoA-System ermittelten
 Tag-Position. Als zentrales Element wurde ein zweidimensionales kartesisches Koordinatensystem verwendet, innerhalb dessen ein einzelner Punkt die 
 Bewegung des Tags repräsentierte. Die Position dieses Punktes wurde entweder durch eine direkte Live-Messung mit der Hardware oder durch eine 
 vereinfachte Simulation erzeugt – eine Möglichkeit zur Wiederverwendung gespeicherter Daten durch einen Datenlogger war zu diesem Zeitpunkt noch nicht
  implementiert.

Zur besseren Nachvollziehbarkeit der geometrischen Zusammenhänge wurden auch die fest installierten Empfangseinheiten (Anker) im Koordinatensystem 
visualisiert. Von deren Positionen ausgehend wurden Linien gezeichnet, welche die gemessenen Einfallswinkel (Angle of Arrival, AoA) darstellten. Die 
Idee dahinter war, die Triangulation – also die Schnittpunktberechnung zweier Richtungslinien – visuell darzustellen und die damit berechnete Tag-Position
 zu validieren.

Allerdings wies diese Darstellung mehrere funktionale und darstellerische Einschränkungen auf. Eine grundlegende Schwäche bestand darin, dass der 
dargestellte Schnittpunkt der Winkel-Linien oft nicht exakt mit dem angezeigten Punkt des Tags übereinstimmte. Dies führte zu Inkonsistenzen, die 
insbesondere bei der Bewertung der Lokalisierungsgenauigkeit zu Verwirrung führen konnten. Die Ursache lag möglicherweise in Rundungsfehlern, unsauberen
 geometrischen Annahmen oder fehlender Synchronisierung zwischen Rechenmodul und Visualisierung.

Darüber hinaus fehlten wichtige Interaktionsmöglichkeiten und Darstellungsmodi: Sensorwerte, Bewegungsgeschwindigkeit oder Risikobewertungen konnten 
nicht separat angezeigt oder analysiert werden. Eine Zoom-Funktion, eine Zeitschrittsteuerung oder ein Replay-Modus waren nicht vorhanden. Da der 
Datenlogger zum damaligen Zeitpunkt noch nicht existierte, beschränkte sich die Funktionalität der Oberfläche auf Live-Datenströme oder manuell 
eingespeiste Simulationsdaten.

Zusammenfassend war die ursprüngliche Visualisierung funktional auf das Wesentliche reduziert, ermöglichte aber weder eine tiefere Analyse noch eine 
Nachbearbeitung historischer Messdaten. Die Einführung des Datenloggers und eine verbesserte Visualisierung sollen diese Defizite beheben und eine 
fundierte, nachvollziehbare sowie interaktive Darstellung aller relevanten Systemparameter ermöglichen.

\subsection{Konzept einer verbesserten Visualisierung}
\subsection{Implementierung der verbesserten Visualisierung}
\subsection{Ergebnisse und Benutzerfreundlichkeit}

\section{Test und Validierung}
\subsection{Testmethodik und -umgebung}
\subsection{Ergebnisse der Tests}
\subsection{Diskussion der Testergebnisse und Optimierungspotentiale}

\section{Kritische Bewertung und Ausblick}
\subsection{Reflexion der erreichten Ergebnisse}
\subsection{Grenzen der aktuellen Umsetzung}
\subsection{Vorschläge für zukünftige Weiterentwicklungen}


\clearpage
%---------------------------------------------------------
% Bibliografie
%---------------------------------------------------------
\begingroup
\renewcommand{\bibfont}{\fontsize{13pt}{12pt}\selectfont}  
\sloppy
\nocite{*}
\printbibliography
\endgroup

\end{document}
